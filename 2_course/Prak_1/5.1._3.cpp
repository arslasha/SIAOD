#include <iostream>    // Подключение библиотеки для работы с вводом/выводом
#include <vector>      // Подключение библиотеки для работы с динамическими массивами (векторами)
#include <bitset>      // Подключение библиотеки для работы с битовыми полями
#include <fstream>     // Подключение библиотеки для работы с файлами
#include <string>      // Подключение библиотеки для работы со строками
#include <chrono>      // Подключение библиотеки для работы с временем
using namespace std;   // Использование стандартного пространства имен

void newFile() {  // Функция для создания нового файла с рандомными числами
    const long n = 1000000;         // Начальное значение для диапазона чисел
    const long n_max = 9999999;     // Конечное значение для диапазона чисел
    const int len = n_max - n + 1;  // Количество элементов в диапазоне
    long* array = new long[len];    // Динамическое выделение массива для чисел

    for (long i = 0; i < len; i++) {  // Заполнение массива числами от n до n_max
        array[i] = n + i;             // Каждому элементу присваивается соответствующее значение
    }
    srand(time(NULL));  // Инициализация генератора случайных чисел текущим временем
    for (long i = 0; i < len; i++)  // Перемешивание массива с помощью случайных перестановок
        swap(array[i], array[rand() % len]);  // Обмен значениями с случайным индексом

    ofstream fout;  // Создание объекта для записи в файл
    fout.open("Text.txt");  // Открытие файла для записи

    if (!fout.is_open())  // Проверка, удалось ли открыть файл
        cout << "Ошибка открытия файла! \n";  // Сообщение об ошибке
    else {
        for (int i = 0; i < len; i++)  // Запись элементов массива в файл построчно
            fout << array[i] << endl;  // Запись числа в файл
    }

    fout.close();  // Закрытие файла
    delete[] array;  // Освобождение памяти, выделенной под массив
}



int main() {
    cout << ("\e[1;1H\e[2J");  // Очистка экрана с помощью escape-последовательности
    setlocale(LC_ALL, "ru");   // Установка локализации для вывода на русском языке

    const int n = 10000000 / 8;  // Определение количества байт для хранения данных
    int num;  // Переменная для хранения чисел из файла
    auto start = chrono::high_resolution_clock::now();  // Замер начала времени выполнения программы
    unsigned char mask = 1;  // Маска для работы с битами
    vector<unsigned char> arr(n);  // Вектор для хранения битовой маски (размер n байт)
    string file = "Text.txt";  // Имя файла для чтения и записи данных
    ifstream fin;  // Создание потока для чтения из файла
    fin.open(file);  // Открытие файла для чтения
    if (!fin.is_open())  // Проверка успешности открытия файла
        cout << "Ошибка" << endl;  // Вывод сообщения об ошибке при открытии файла
    else {
        while (!fin.eof()) {  // Пока не достигнут конец файла
            fin >> num;  // Чтение числа из файла
            arr[num / 8] |= (mask << num % 8);  // Установка соответствующего бита в массиве
        }
    }

    fin.close();  // Закрытие файла после чтения данных
    auto end = chrono::high_resolution_clock::now();  // Замер конца времени выполнения программы
    ofstream fout;  // Создание потока для записи в файл
    fout.open(file);  // Открытие файла для записи
    if (!fout.is_open())  // Проверка успешности открытия файла для записи
        cout << "Ошибка открытия файла!\n";  // Вывод сообщения об ошибке при открытии файла
    else {
        for (int i = 0; i < n; i++) {  // Проход по каждому байту массива
            for (int j = 0; j < 8; j++) {  // Проход по каждому биту в байте
                if ((arr[i] & 1) == 1)  // Проверка, установлен ли бит
                    fout << 8 * i + j << endl;  // Запись позиции установленного бита в файл
                arr[i] >>= 1;  // Сдвиг байта на один бит вправо
            }
        }
    }
    fout.close();  // Закрытие файла после записи данных
    chrono::duration<double, milli> duration = end - start;  // Вычисление времени выполнения программы
    arr.shrink_to_fit();  // Освобождение лишней памяти, занятой вектором
    cout << arr.capacity() << " b\n";  // Вывод объема выделенной памяти в байтах
    cout << arr.capacity() / 1024 << " kb\n";  // Вывод объема выделенной памяти в килобайтах
    cout << arr.capacity() / (1024 * 1024) << " mb\n";  // Вывод объема выделенной памяти в мегабайтах
    cout << "Время работы алгоритма: " << duration.count() << " миллисекунд\n";  // Вывод времени выполнения программы
}
